# ============================================================
# AUTO-GENERATED FILES FROM TEMPLATES
# ============================================================
# This file contains the Terraform configuration for automatically
# generating inventory.ini and Jenkinsfile with correct IP addresses.
#
# HOW IT WORKS:
# 1. Terraform creates EC2 instances and Elastic IPs
# 2. Once IPs are known, Terraform reads the template files
# 3. It replaces ${variable} placeholders with actual values
# 4. It writes the result to the target file location
#
# BENEFITS:
# - No more manual IP updates after terraform apply!
# - inventory.ini and Jenkinsfile are always in sync with infrastructure
# - Destroy and recreate without editing files
#
# THE templatefile() FUNCTION:
# Syntax: templatefile(path_to_template, { variable_map })
#
# Example:
#   templatefile("templates/inventory.ini.tpl", {
#     app_server_ip = "1.2.3.4"
#   })
#
# This reads the template and replaces ${app_server_ip} with "1.2.3.4"
# ============================================================

# ------------------------------------------------------------
# Variables for SSH configuration (used in templates)
# ------------------------------------------------------------
# These let you configure SSH settings in one place
# Default values match what's commonly used in the project
# ------------------------------------------------------------

variable "ssh_key_path" {
  description = "Path to SSH private key file (for Ansible inventory)"
  type        = string
  default     = "~/.ssh/klinkr-key.pem"
}

variable "ssh_user" {
  description = "SSH username for the servers (admin for Debian)"
  type        = string
  default     = "admin"
}

# ------------------------------------------------------------
# AUTO-GENERATE: Ansible Inventory File
# ------------------------------------------------------------
# Creates: ../ansible/inventory.ini
# Template: templates/inventory.ini.tpl
#
# This file tells Ansible where your servers are and how to
# connect to them. After terraform apply, it will contain
# the actual Elastic IP addresses.
# ------------------------------------------------------------

resource "local_file" "ansible_inventory" {
  # The content is generated by reading the template and replacing variables
  content = templatefile("${path.module}/templates/inventory.ini.tpl", {
    # These variables are available in the template as ${variable_name}
    app_server_ip     = aws_eip.app_server.public_ip      # VM1's Elastic IP
    jenkins_server_ip = aws_eip.jenkins_server.public_ip  # VM2's Elastic IP
    ssh_user          = var.ssh_user                       # "admin" for Debian
    ssh_key_path      = var.ssh_key_path                   # Path to .pem file
  })

  # Where to write the generated file
  filename = "${path.module}/../ansible/inventory.ini"

  # File permissions (read/write for owner, read for others)
  file_permission = "0644"
}

# ------------------------------------------------------------
# AUTO-GENERATE: Jenkinsfile
# ------------------------------------------------------------
# Creates: ../Jenkinsfile
# Template: templates/Jenkinsfile.tpl
#
# This file defines the Jenkins CI/CD pipeline. After terraform
# apply, the APP_SERVER variable will have the correct IP.
# ------------------------------------------------------------

resource "local_file" "jenkinsfile" {
  content = templatefile("${path.module}/templates/Jenkinsfile.tpl", {
    app_server_ip = aws_eip.app_server.public_ip  # VM1's Elastic IP
    ssh_user      = var.ssh_user                   # "admin" for Debian
  })

  filename = "${path.module}/../Jenkinsfile"

  file_permission = "0644"
}
